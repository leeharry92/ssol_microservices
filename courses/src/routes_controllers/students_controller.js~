var utils    = require( '../../utils' );

// require the database, which has already been connected
var students_db = require('../schemas/students_db.js');
var model = students_db.model('students_model');


var pagetitle = "Students Info";
var ioLabel = "student"; //used for webpage editing
var root = '/students/';


// routes.index handler
exports.index = function (REST_CALL, io){
	// need this return syntax because we are passing io from app.js
	return function(req, res, next ){


	  // assign a unique ID
	  var user_id = req.cookies ?
		req.cookies.user_id : undefined;

	  model.
		find({ user_id : user_id }).
		sort( '-updated_at' ).
		exec( function ( err, models ){

			if( err ) return next( err );

			if (REST_CALL){

				res.json(models);

			} else{

			console.log("index1");
				// render the webpage with a title and schema instances
				res.render( 'index.jade', {
				  title : pagetitle,
				  models : models, //pass the schema instances
				  path : root,
				  ioLabel : ioLabel
				});
			}

		});
	}; // ends return
}; // ends exports.index


// routes.create handler
exports.create = function (io) {
    return function(req, res, next) {
        console.log("exports.create1");

	  new model({
		  user_id    : req.cookies.user_id,
		  name		 : req.body.name,
		  content    : req.body.contents,//["randcourse1","randcourse2"],
		  updated_at : Date.now()
	  }).save( function ( err, model, count ){
	console.log("create1a");
			if( err ) return next( err );
			console.log("create1b");
			io.emit('createStudent', model);
			res.redirect( root );
			console.log("create1redirect: "+root);
		
	  });


    };
};




exports.destroyname = function (REST_CALL, io) {
    return function(req, res, next) {
        console.log("exports.destroyname1");

	  model.findById( req.params.id, function ( err, model ){
		var user_id = req.cookies ?
		  req.cookies.user_id : undefined;
	
	/*
		if( model.user_id !== user_id ){
		  return utils.forbidden( res );
		}
	*/

		model.remove( function ( err, destroy_model ){
		  if( err ) return next( err );

			io.emit('destroyname', destroy_model._id);

			if (REST_CALL){
				console.log("REST");
				res.json(destroy_model);
			} else {
			  	res.redirect( root );
			};

		});
	  });


    };
};




exports.destroycontent = function (REST_CALL, io) {
    return function(req, res, next) {
        console.log("exports.destroycontent1");

	  model.findById( req.params.id, function ( err, model ){
		var user_id = req.cookies ?
		  req.cookies.user_id : undefined;
	
	/*
		if( model.user_id !== user_id ){
		  return utils.forbidden( res );
		}
	*/

		// build a new content array, excluding the element removed 
		console.log(model.content);
		var index2exclude = 1;
		var newContentArray = [];
		for (var i = 0; i < model.content.length; i++){
			if (i == index2exclude){
			} else {
				newContentArray.push(model.content[i]);
			}
		}
		model.content = newContentArray;

		// save the new model
		model.save( function ( err, model, count ){
			if( err ) return next( err );

			io.emit('destroycontent', {data: model._id, courseindex: index2exclude});

			res.redirect( root );
		});


	  });



    };
};



exports.editname = function( req, res, next ){
  var user_id = req.cookies ?
      req.cookies.user_id : undefined;


  model.
    find({ user_id : user_id }).
    sort( '-updated_at' ).
    exec( function ( err, models ){
      if( err ) return next( err );

      res.render( 'edit.jade', {
        title   : pagetitle,
        models   : models,
        current : req.params.id,
		path : root,
		ioLabel : ioLabel
      });
    });
};



exports.edittest = function (REST_CALL) {
    return function(req, res, next) {
        console.log("exports.edittest1");

	  var user_id = req.cookies ?
		  req.cookies.user_id : undefined;

	  // if a REST CALL was rendered, return JSON
	  if (REST_CALL) {
		  model
			.findById(req.params.id, function(err, results) {
				return res.send({
				  user_id    : results.user_id,
				  name		 : results.name,
				  content    : results.content,
				  updated_at : Date.now()
				});
			});
	  } else {
		  var webpage = true; // if rendered via GUI
		  model.
			find({ user_id : user_id }).
			sort( '-updated_at' ).
			exec( function ( err, models ){
			  if( err ) return next( err );

			  res.render( 'edit.jade', {
				title   : pagetitle,
				models   : models,
				current : req.params.id,
				root : root,
				ioLabel : ioLabel
			  });
			});

		}; // ends else


    };
};




exports.update = function( io) {

	return function ( req, res, next ){

	  model.findById( req.params.id, function ( err, model ){
		var user_id = req.cookies ?
		  req.cookies.user_id : undefined;

		if( model.user_id !== user_id ){
		  return utils.forbidden( res );
		}

		model.name    = req.body.name;
		model.content    = req.body.content;
		model.updated_at = Date.now();
		model.save( function ( err, model, count ){

			if( err ) return next( err );
			io.emit('update', "update");
			res.redirect( root );

		});
	  });


	}
};

/*

// ** express turns the cookie key to lowercase **
exports.current_user = function ( req, res, next ){
  var user_id = req.cookies ?
      req.cookies.user_id : undefined;

  if( !user_id ){
    res.cookie( 'user_id', utils.uid( 32 ));
  }

  next();
};

*/

